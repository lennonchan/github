//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : Rootview.cpp
//  @ Date : 2012-11-20
//  @ Author : 
//
//


#include "Rootview.h"
#include "ViewNode.h"
#include "TranslationAnm.h"
#include "Aabridge.h"
#include "FocusMovePath.h"
#include "gkEntity.h"

#define _ROOTVIEW_FOCUSNAME_	"AaFocus"
#define _ROOTVIEW_CIRCLE_		"line_01b"//"Plane_zw07"
#define _ROOTVIEW_RECT_			"line_01"//"Plane_zw06"
#define _ROOTVIEW_FOCUS_OFFSET	gkVector3(0,0,-0.01)

TranslationAnm* RootView::pAaFocus = NULL;
gkGameObject* RootView::m_pFocusObj = NULL;
int RootView::m_CircleTextureID = 0;
int RootView::m_RectTextureID = 0;

RootView::RootView(bool visible):m_iNodeNum(0),m_pFocusNode(NULL),m_ppViewNodeList(NULL),m_visible(visible)
{
	if(!pAaFocus && !m_pFocusObj)
	{
		m_pFocusObj = Aabridge::getScene()->getObject(_ROOTVIEW_FOCUSNAME_);
		m_pFocusObj->setVisible(false);
		m_pFocusObj->setObjectRenderPriority(80);
		pAaFocus = new TranslationAnm(Aabridge::getScene(),m_pFocusObj,"AaFocus",_ROOTVIEW_FOCUS_OFFSET,_ROOTVIEW_FOCUS_OFFSET);
		//Ogre::Pass* pPass  = m_pFocusObj->getCurrentOgrePass(0);
		m_CircleTextureID = ((gkEntity*)Aabridge::getScene()->getObject(_ROOTVIEW_CIRCLE_))->getGLTextureID(0,0);

		//pPass = Aabridge::getScene()->getObject(_ROOTVIEW_RECT_)->getCurrentOgrePass(0);
		m_RectTextureID = ((gkEntity*)Aabridge::getScene()->getObject(_ROOTVIEW_RECT_))->getGLTextureID(0,0);
	}
}

RootView::~RootView()
{
	ui_deleteArray(m_ppViewNodeList,m_iNodeNum);
	ui_delete(pAaFocus);
}

bool 
RootView::setFocus(ViewNode* node,bool isCircle)
{
	_ASSERT_(node);

	if (isCircle)
	{
		//m_pTextureState->_getTexturePtr()->setGLID(m_CircleTextureID);
		((gkEntity*)m_pFocusObj)->setGLTextureID(0,0,m_CircleTextureID);
	}
	else
	{
		//m_pTextureState->_getTexturePtr()->setGLID(m_RectTextureID);
		((gkEntity*)m_pFocusObj)->setGLTextureID(0,0,m_RectTextureID);
	}
	gkTransformState state = node->getGameObj()->getWorldTransformState();

	//pAaFocus->m_pGameObj->setPosition(pos);
	//state.scl.y += -0.5; 

	pAaFocus->To(state.loc,state.scl*1.05);

	pAaFocus->Fly();

	m_pFocusNode = node;

	return false;
}

bool 
RootView::setFocus(int index,bool isCircle)
{
	if(index < 0 || index >= m_iNodeNum )
		return false;

	for (int i = 0;i<m_iNodeNum;i++)
	{
		ViewNode* pApp = m_ppViewNodeList[i];
		//判断当前idx是否落在这个图标的范围内
		if (pApp->getMinIndex() <= index && pApp->getMaxIndex()>=index)
		{
			return setFocus(pApp,isCircle);
		}
	}
	return true;
}

void 
RootView::setFocusVisible(bool vsb)
{
	m_pFocusObj->setVisible(vsb);
}

int 
RootView::getCircleTextureID()
{
	return m_CircleTextureID;
}

int 
RootView::getRectTextureID()
{
	return m_RectTextureID;
}

gkGameObject *
RootView::getAaFocusObj()
{
	return m_pFocusObj;
}

ViewNode* 
RootView::getFocus()
{
	return m_pFocusNode;
}

RootView* 
RootView::setTAnmInterface(TranslationAnmInterface* interf)
{
	m_pTAnmInterFace = interf;
	return this;
}

void 
RootView::onTick(gkScalar time)
{
	if(pAaFocus)
		pAaFocus->Update(time);
	return;	
}

bool 
RootView::isFocusNode(ViewNode* pNode)
{
	gkTransformState stateNode = pNode->getGameObj()->getWorldTransformState();
	gkTransformState stateFocus = m_pFocusObj->getWorldTransformState();
	if(stateFocus.loc-_ROOTVIEW_FOCUS_OFFSET == stateNode.loc)
		return true;
	return false;

}

void 
RootView::setViewNodeNum(int n)
{
	m_iNodeNum = n;
}

int 
RootView::getViewNodeNum()
{
	return m_iNodeNum;
}

ViewNode** 
RootView::getViewNodeList() 
{
	return m_ppViewNodeList;
}

void 
RootView::setViewNodeList(ViewNode** ppVn) 
{
	m_ppViewNodeList = ppVn;
}

bool 
RootView::isInvolvedViewNode(ViewNode* pList[],ViewNode* pCurrent,const int length)
{
	if(!pList || !pCurrent)
		return false;
	for (int i = 0;i<length;i++)
	{
		if(pList[i] == pCurrent)
			return true;
	}

	return false;
}

void 
RootView::setVisible(bool visible)
{
	if(m_visible == visible)
		return;
	m_visible = visible;
	visible?showView():hideView();
}

bool 
RootView::getVisible()
{
	return m_visible;
}

void 
RootView::showView()
{
	for (int i = 0;i<m_iNodeNum;i++)
	{
		m_ppViewNodeList[i]->getGameObj()->setVisible(true);
	}
}

void 
RootView::hideView()
{
	for (int i = 0;i<m_iNodeNum;i++)
	{
		m_ppViewNodeList[i]->getGameObj()->setVisible(false);
	}
}

ViewNode* 
RootView::isHitViewNode(Ogre::RaySceneQueryResult& objArray)
{
	if(!m_visible)		// 如果此view不可见
		return NULL;

	gkGameObject* pObj = NULL;
	for (int i = 0;i<m_iNodeNum;i++)
	{
		pObj = m_ppViewNodeList[i]->getGameObj();
		if(pObj->getVisible() && isObjInArray(objArray,pObj))
			return m_ppViewNodeList[i];
	}

	return NULL;
}