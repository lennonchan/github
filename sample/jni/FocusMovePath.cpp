//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : Untitled
//  @ File Name : Focus.cpp
//  @ Date : 2012-11-6
//  @ Author : 
//
//


#include "FocusMovePath.h"

#define  _SUB_VIEWPORT_Z_	-15.0f

ViewNode* 
FocusMovePath::isInvolved(ViewNode* pList[],gkGameObject* pCurrent,const int length)
{
	for (int i = 0;i < length; i++ )
	{
		if (pCurrent == pList[i]->getGameObj())
		{
			return pList[i];
		}
	}

	return NULL;
}
bool 
FocusMovePath::isInvolved(ViewNode** pList,ViewNode* pCurrent,const int length)
{
	for (int i = 0;i < length; i++ )
	{
		if (pCurrent == pList[i])
		{
			return true;
		}
	}

	return false;
}

ViewNode* 
FocusMovePath::getByIndex(ViewNode* pList[],int index,const int length)
{
	for (int i = length -1;i >=0; i-- )
	{
		if (pList[i]->getMinIndex() <= index && pList[i]->getMaxIndex() >= index)
		{
			return pList[i];
		}
	}

	return NULL;
}

int 
FocusMovePath::CalculateIndex( int currentSelect , eFlyDirection controlID )
{
	int temp = currentSelect;
	switch(controlID)
	{
	case LEFT:
		temp--;
		//在同一行
		if (currentSelect > 0 && temp/3 != currentSelect/3)
		{
			temp = -1000;
		}
		else if(currentSelect == 0)
		{
			temp = -1000;
		}
		else if (currentSelect < 0 && currentSelect%3 == 0)
		{
			temp = -1000;
		}
		break;
	case RIGHT:
		temp ++;
	
		if (currentSelect > 0 && temp/3 != currentSelect/3)
		{
			temp = 1000;
		}
		else if (currentSelect < 0 && currentSelect%3 == -1)
		{
			temp = 1000;
		}
		break;
	case UP:
		temp -=3;
		break;
	case DOWN:
		temp +=3;
		break;
	default:
		break;
	}

	return temp ;
}

ViewNode* 
FocusMovePath::getNextFocusNode_HomeBlock(ViewNode* pList[],ViewNode* pCurrent,const eFlyDirection direct,const int length)
{
	if(!pList || !pCurrent)
		return NULL;
	ViewNode* pTemp = NULL;
	if (!pCurrent) return NULL;
	int index = pCurrent->getMinIndex();
	//是否在当前block
	if (isInvolved(pList,pCurrent,length))
	{
NAK:
		index = CalculateIndex(index,direct);
		if (index >= pCurrent->getMinIndex() && index <= pCurrent->getMaxIndex())		// 有的模块有两个index
		{
			pTemp = getByIndex(pList,index,length);
			if (pCurrent != pTemp)
			{
				return pTemp;
			}
			goto NAK;
		}
		if (index == 1000 || index == -1000)
		{
			return NULL;			// 向左或向右翻页
		}
		int flag = index;

		do 
		{
			pTemp = getByIndex(pList,index,length);
			index--;

		} while (!pTemp&&(index+1)%3 != 0);
		
	}
	else
	{
		if (direct == LEFT)
		{
			int index = pCurrent->getMinIndex() == -6?-3:pCurrent->getMinIndex()+2;
			do 
			{
				pTemp = getByIndex(pList,index,length);
				index--;

			} while (!pTemp && index>=-6);
		}
		else if (direct == RIGHT)
		{
			int index = pCurrent->getMinIndex()/3 *3 ;
			do 
			{
				pTemp = getByIndex(pList,index,length);
				index++;

			} while (!pTemp&& index<=11);
		}
		else if (direct == UP)
		{
			int index = pCurrent->getMinIndex()-3 ;

			do 
			{
				pTemp = getByIndex(pList,index,length);
				index++;

			} while (!pTemp&& index<=11);
		}
		else if (direct == DOWN)
		{
			int index = pCurrent->getMinIndex()+3 ;

			do 
			{
				pTemp = getByIndex(pList,index,length);
				index++;

			} while (!pTemp&& index<=11);
		}
	}

	return pTemp;
}

AppUnit* 
FocusMovePath::getNextFocusNode_AaBack(vector<AppUnit*>*  pvList,unsigned int focusIndex,const eFlyDirection direct,const unsigned int colNum)
{
	_ASSERT_(pvList && colNum!=0);
	AppUnit* pResult = NULL;
	
	switch(direct)
	{
	case LEFT:
		pResult = focusIndex%colNum == 0? NULL:pvList->at(focusIndex-1);
		break;
	case RIGHT:		
		if (focusIndex % colNum != colNum-1 && focusIndex != pvList->size() - 1)
		{
			pResult = pvList->at(focusIndex + 1);
		}

		break;
	case UP:
		pResult = focusIndex < colNum? pvList->at(focusIndex):pvList->at(focusIndex-colNum);
		break;
	case DOWN:
		if((focusIndex+colNum) < pvList->size())
		{
			pResult = pvList->at(focusIndex+colNum);
		}
		else
		{
			if(focusIndex/colNum == (pvList->size() - 1)/colNum)
			{
				pResult = pvList->at(focusIndex);
			}
			else
			{
				pResult = pvList->at(pvList->size() - 1);
			}
		}
		break;
	default:
		pResult = NULL;
		break;
	}

	//MYLOGI("%d, %d \n", focusIndex, pvList->size());
	return pResult;
}

ViewNode* 
FocusMovePath::getNodeByVIndex(ViewNode** pList,const unsigned int length,unsigned int focusIndex)
{
	_ASSERT_(pList&&length!=0);
	for (unsigned int i = 0;i<length;i++)
	{
		if(focusIndex>=pList[i]->getMinIndex() && focusIndex<=pList[i]->getMaxIndex())
			return pList[i];
	}
	return NULL;
}

ViewNode* 
FocusMovePath::getNextFocusNode_AA(ViewNode** pList,const unsigned int length,unsigned int focusIndex,const eFlyDirection direct,const unsigned int colNum)
{
	_ASSERT_(pList && colNum!=0 && focusIndex<length);
	ViewNode* pResult = NULL,*pFocus = getNodeByVIndex(pList,length,focusIndex);
	int index = -1;
	switch(direct)
	{
	case LEFT:
		index = focusIndex%colNum == 0? -1:focusIndex-1;
		break;
	case RIGHT:
		index = focusIndex%colNum == colNum-1?-1:focusIndex+1;//focusIndex == length - 1? pList[focusIndex]:pList[focusIndex+1];
		break;
	case UP:
		index = focusIndex < colNum? -1:focusIndex-colNum;
		break;
	case DOWN:
		if((focusIndex+colNum) <length)
		{
			index = focusIndex+colNum;
		}
		else
		{
			if(focusIndex/colNum == (length - 1)/colNum)
			{
				index = -1;
			}
			else
			{
				index = length - 1;
			}
		}
		break;
	default:
		index = -1;
		break;
	}
	
	if (index == -1 || index >= length)
	{
		return NULL;
	}
	pResult = getNodeByVIndex(pList,length,index);
	if(pFocus == pResult)
		return getNextFocusNode_AA(pList,length,index,direct,colNum);
	return pResult;
}